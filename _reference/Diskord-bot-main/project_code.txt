import discord
from discord.ext import commands
import asyncio
import asyncpg
from datetime import datetime, timezone
import os
from dotenv import load_dotenv
from aiohttp import web
import json

load_dotenv()

# --- CONFIGURATION ---
# Ensure your .env file has DISCORD_TOKEN, DB_USER, DB_PASSWORD, DB_NAME
TOKEN = os.getenv("DISCORD_TOKEN") 
CHANNEL_ID_SEND = 1441380472579162285   
CHANNEL_ID_LOGS = 1441383049794420746   
GLOBAL_SEND_ID = 1441380472579162285 
BIG_ACTION_ID = 1441383700368724078 
ADMIN_ROLE_ID = 1441382969628426240 

DB_CONFIG = {
    "database": os.getenv("DB_NAME", "postgres"),
    "user": os.getenv("DB_USER", "postgres"),
    "password": os.getenv("DB_PASSWORD", "password"),
    "host": os.getenv("DB_HOST", "localhost"),
    "port": os.getenv("DB_PORT", "5432"),
}

ADMIN = {777206368389038081}

intents = discord.Intents.default()
intents.message_content = True
intents.messages = True
intents.members = True
bot = commands.Bot(command_prefix="C7/", intents=intents)

# Globals
db_pool = None
send_channel = None
logs_channel = None
global_send = None
big_action = None
waiting_users = {}

# Colors
psi_yellow = 0xffe989
goldish = 0xcfb54e
dark_red = 0xad1f1f

# --- API SERVER SETUP (WEBSITE BACKEND) ---
routes = web.RouteTableDef()

def cors_headers():
    return {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
    }

def json_response(data, status=200):
    return web.Response(
        text=json.dumps(data, default=str),
        content_type='application/json',
        status=status,
        headers=cors_headers()
    )

@routes.options('/{tail:.*}')
async def handle_options(request):
    return web.Response(status=204, headers=cors_headers())

@routes.get('/api/status')
async def handle_status(request):
    return json_response({'status': 'online', 'latency': round(bot.latency * 1000)})

@routes.get('/api/servers')
async def handle_servers(request):
    servers = []
    for guild in bot.guilds:
        servers.append({
            'id': str(guild.id),
            'name': guild.name,
            'icon': str(guild.icon.url) if guild.icon else None
        })
    return json_response(servers)

# --- FOLDER ROUTES ---

@routes.get('/api/folders')
async def handle_folders_get(request):
    if not db_pool: return json_response([], 500)
    async with db_pool.acquire() as conn:
        try:
            rows = await conn.fetch("SELECT id, name, color FROM folders ORDER BY id ASC")
            folders = [{'id': str(r['id']), 'name': r['name'], 'color': r['color'] or '#FFE989'} for r in rows]
            return json_response(folders)
        except Exception as e:
            print(e)
            return json_response([], 200)

@routes.post('/api/folders')
async def handle_folder_create(request):
    data = await request.json()
    name = data.get('name')
    if not name: return json_response({'error': 'Name required'}, 400)
    async with db_pool.acquire() as conn:
        await conn.execute("INSERT INTO folders (name, color, admins) VALUES ($1, $2, $3)", name, '#FFE989', [])
    return json_response({'status': 'created'})

@routes.get('/api/folders/{id}/servers')
async def handle_folder_servers_get(request):
    folder_id = int(request.match_info['id'])
    if not db_pool: return json_response([], 500)
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT server_id, server_name FROM server_folders WHERE folder_id=$1", folder_id)
        servers = [{'id': str(r['server_id']), 'name': r['server_name']} for r in rows]
        return json_response(servers)

@routes.post('/api/folders/{id}/servers')
async def handle_folder_server_add(request):
    folder_id = int(request.match_info['id'])
    data = await request.json()
    server_id = data.get('serverId')
    
    # Try to resolve server name from bot cache, otherwise generic
    server_name = f"Server {server_id}"
    try:
        guild = bot.get_guild(int(server_id))
        if guild: server_name = guild.name
    except:
        pass

    if not server_id: return json_response({'error': 'Server ID required'}, 400)
    
    async with db_pool.acquire() as conn:
        await conn.execute("""
            INSERT INTO server_folders (folder_id, server_id, server_name) 
            VALUES ($1, $2, $3)
            ON CONFLICT (folder_id, server_id) DO NOTHING
        """, folder_id, int(server_id), server_name)
    return json_response({'status': 'added'})

# --- LOG ROUTES ---

@routes.get('/api/logs/messages')
async def handle_logs_messages(request):
    if not db_pool: return json_response([])
    try:
        async with db_pool.acquire() as conn:
            rows = await conn.fetch("SELECT folder, username, content, timestamp, user_id FROM saved_msg ORDER BY timestamp DESC LIMIT 50")
        logs = []
        for r in rows:
            variant = "variant-red" if "dao" in str(r['folder']).lower() else "variant-brown"
            logs.append({
                'server': r['folder'],
                'user': r['username'],
                'userId': str(r['user_id']),
                'content': r['content'],
                'time': r['timestamp'].strftime('%d.%m.%Y %H:%M'),
                'variant': variant
            })
        return json_response(logs)
    except:
        return json_response([])

@routes.post('/api/send')
async def handle_api_send(request):
    data = await request.json()
    target_id = data.get('targetId')
    message = data.get('message')
    if not target_id or not message: return json_response({'error': 'Missing fields'}, 400)
    try:
        channel = bot.get_channel(int(target_id))
        if channel:
            await channel.send(message)
            return json_response({'status': 'sent to channel'})
        user = await bot.fetch_user(int(target_id))
        if user:
            await user.send(message)
            return json_response({'status': 'sent to user'})
        return json_response({'error': 'not found'}, 404)
    except Exception as e:
        return json_response({'error': str(e)}, 500)


# --- BOT LOGIC (Original Features) ---

class SaveView(discord.ui.View):
    def __init__(self, message: discord.Message = None):
        super().__init__(timeout=None)
        if message is None: return
        custom_id = f"save|{message.author.id}|{message.channel.id}|{message.id}"
        self.add_item(discord.ui.Button(label="Save", style=discord.ButtonStyle.primary, custom_id=custom_id))

    async def interaction_check(self, interaction: discord.Interaction):
        parts = interaction.data["custom_id"].split("|")
        _, user_id, channel_id, message_id = parts
        channel = bot.get_channel(int(channel_id))
        msg = await channel.fetch_message(int(message_id))
        waiting_users[interaction.user.id] = {
            "user_id": int(user_id),
            "username": str(msg.author),
            "content": msg.content,
            "channel_id": int(channel_id),
            "message_id": int(message_id)
        }
        await interaction.response.send_message("Send folder name or No/None/Default/- for default.", ephemeral=True)
        return False

@bot.event
async def on_ready():
    global send_channel, logs_channel, big_action, global_send
    send_channel = bot.get_channel(CHANNEL_ID_SEND)
    logs_channel = bot.get_channel(CHANNEL_ID_LOGS)
    big_action = bot.get_channel(BIG_ACTION_ID)
    global_send = bot.get_channel(GLOBAL_SEND_ID)
    print(f"{bot.user} ready")
    
    # Initialize Database Tables
    if db_pool:
        async with db_pool.acquire() as conn:
            # Members table
            await conn.execute("""
            CREATE TABLE IF NOT EXISTS members (
                id SERIAL PRIMARY KEY,
                user_id BIGINT UNIQUE NOT NULL,
                username TEXT,
                join_date TIMESTAMPTZ
            );
            """)
            # Saved Messages table
            await conn.execute("""
            CREATE TABLE IF NOT EXISTS saved_msg (
                id SERIAL PRIMARY KEY,
                user_id BIGINT REFERENCES members(user_id),
                folder TEXT,
                username TEXT,
                content TEXT,
                timestamp TIMESTAMPTZ,
                channel_id BIGINT,
                message_id BIGINT
            );
            """)
            # Folders table
            await conn.execute("""
            CREATE TABLE IF NOT EXISTS folders (
                id SERIAL PRIMARY KEY,
                name TEXT NOT NULL,
                color TEXT,
                admins TEXT[]
            );
            """)
            # Server-Folder Relation table
            await conn.execute("""
            CREATE TABLE IF NOT EXISTS server_folders (
                folder_id INTEGER REFERENCES folders(id) ON DELETE CASCADE,
                server_id BIGINT,
                server_name TEXT,
                PRIMARY KEY (folder_id, server_id)
            );
            """)
            print("Database tables checked/created.")
    bot.add_view(SaveView())

@bot.event
async def on_message(message: discord.Message):
    if message.author == bot.user: return
    if message.content.startswith(bot.command_prefix):
        await bot.process_commands(message)
        return

    # Log member join date
    if db_pool:
        async with db_pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO members (user_id, username, join_date)
                VALUES ($1, $2, $3)
                ON CONFLICT (user_id) DO NOTHING
            """, message.author.id, str(message.author), datetime.now(timezone.utc))

    # Folder saving response logic
    user_id = message.author.id
    if user_id in waiting_users:
        folder_input = message.content.strip()
        saved_message = waiting_users[user_id]
        if folder_input.lower() in ['no', 'none', 'default', '-']:
            folder_input = 'default'
        
        if db_pool:
            async with db_pool.acquire() as conn:
                await conn.execute("""
                    INSERT INTO saved_msg (user_id, folder, username, content, timestamp, channel_id, message_id)
                    VALUES ($1, $2, $3, $4, $5, $6, $7)
                """, saved_message['user_id'], folder_input, saved_message['username'], 
                saved_message['content'], datetime.now(timezone.utc),
                saved_message['channel_id'], saved_message['message_id'])
        await message.reply("message saved")
        del waiting_users[user_id]
        return

    # Log Embed to Channel
    if logs_channel:
        embed = discord.Embed(
            title="Message sent",
            description=f"**{message.author}** ({message.author.id}) sent\n```{message.content}```\nin {message.channel.mention}",
            color=psi_yellow
        )
        embed.set_author(name=str(message.author), icon_url=message.author.avatar.url if message.author.avatar else None)
        view = SaveView(message)
        await logs_channel.send(embed=embed, view=view)

    await bot.process_commands(message)

# --- COMMANDS ---

@bot.command(name="show_saved")
async def show_saved(ctx, folder: str = None):
    folder = folder or "default"
    if not db_pool: return await ctx.send("DB Error")
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT * FROM saved_msg WHERE folder=$1 ORDER BY timestamp ASC", folder)
    if not rows: return await ctx.send(f"No logs in {folder}")
    await ctx.send(f"Found {len(rows)} messages in '{folder}'. Check console for full history.")

@bot.command(name="global_send")
async def global_sending(ctx, guild_id: int, channel_id: int, *, content: str):
    if ctx.author.id not in ADMIN: return
    channel = bot.get_channel(channel_id)
    if channel: await channel.send(content)

@bot.command(name="heaven_strike")
async def heaven_strike(ctx, big: bool, user_id: int, guild_id: int, *, reason: str = None):
    if ctx.author.id not in ADMIN: return
    guild = bot.get_guild(guild_id)
    if guild:
        try:
            await guild.ban(discord.Object(id=user_id), reason=reason)
            await ctx.send("Struck.")
            if big and big_action: await big_action.send(f"Banned {user_id}")
        except Exception as e:
            await ctx.send(f"Failed: {e}")

# --- EXECUTION ---
async def main():
    global db_pool
    if DB_CONFIG["password"]:
        try:
            db_pool = await asyncpg.create_pool(**DB_CONFIG)
            print("DB Connected")
        except Exception as e:
            print(f"DB Failed: {e}")
    
    # Start Web Server (for Website)
    app = web.Application()
    app.add_routes(routes)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 5000)
    await site.start()
    print("API Server listening on http://localhost:5000")

    # Start Bot
    async with bot:
        await bot.start(TOKEN)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
